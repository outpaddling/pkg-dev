#!/bin/sh -e

##########################################################################
#   Script description:
#       Generate a basic pbulk setup for a given pkgsrc prefix.
#       
#   Arguments:
#       None.
#
#   Returns:
#       
#   History:
#   Date        Name        Modification
#   2017-04-29  Jason Bacon Begin
##########################################################################

usage()
{
    printf "Usage: $0\n"
    exit 1
}


##########################################################################
#   Function description:
#       
#   Arguments:
#       
#   Returns:
#       
#   History:
#   Date        Name        Modification
#   2017-05-16  root        Begin
##########################################################################

auto_ask()
{
    if [ $# != 3 ]; then
	cat << EOM > /dev/stderr
Usage: $0 tag "question" default-answer

    'tag' is a name used to uniquely identify this question in the
    recorded responses.  It must be a single word without spaces or
    special shell characters, and must be unique across all calls
    to $0.
    
    'question' must be enclosed in quotes if it contains spaces or
    special characters.
    
    'default-answer' must also be encloded in quotes if it contains
    spaces or special characters.

EOM
	exit 1
    fi

    tag=$1
    question="$2"
    
    response_file=auto-ask-responses.txt
    touch $response_file
    
    default_response="`awk -F'|' '$1 == "'$tag'" { print $2 }' $response_file`"
    if [ 0"$default_response" = 0 ]; then
	default_response="$3"
    fi
    
    valid=0
    while [ $valid = 0 ]; do
	printf "$question [$default_response] " > /dev/stderr
	read resp
	# resp cannot contain '|'
	if echo "$resp" | fgrep '|'; then
	    printf "Sorry, responses cannot contain '|'.\n" > /dev/stderr
	else
	    valid=1
	fi
    done
    
    if [ 0"$resp" = 0 ]; then
	resp="$default_response"
    fi
    
    awk -F'|' '$1 != "'$tag'" { print $0 }' $response_file > $response_file.temp
    mv -f $response_file.temp $response_file
    printf "${tag}|${resp}\n" >> $response_file
    
    printf "$resp\n"
    return 0
}


##########################################################################
#   Main
##########################################################################

if [ $# != 0 ]; then
    usage
fi

if [ `whoami` != root ]; then
    printf "$0 must be run by root.\n"
    exit 1
fi

cat << EOM

$0 should only be run in a chroot, VM, or on a system that is
dedicated exclusively to pbulk builds.  It will remove all installed
packages and perform extensive reconfiguration of your system.

EOM

printf "Continue? yes/[no] "
read continue
if [ 0$continue != 0yes ]; then
    exit
fi

cat << EOM

Enter the location of the pkgsrc tree from which you want to build packages.
The source directory will be mounted read/write within the chroot, but
work directories will be written there.

The install prefix will be recreated within the chroot environment.  This
will be the prefix to which packages generated by pbulk will install.  It
need not match anything outside the chroot.

The var and pkgdb directories will also be located under this prefix.

EOM

pkgsrc=`auto_ask source-prefix 'Pkgsrc source directory?' /usr/pkgsrc`
if [ ! -e $pkgsrc ]; then
    printf "$pkgsrc does not exist.  Please download and extract pkgsrc first.\n"
    exit 1
fi

prefix=`auto_ask bin-prefix 'Pkgsrc install prefix?' /usr/pkg`

# pbulk_dir=`auto_ask pbulk-prefix 'Pbulk install prefix?' /usr/pbulk`

make_jobs=`auto_ask make-jobs 'Max # processes for make to use?' 4`

rsync_user=`auto_ask rsync-user 'rsync username (leave blank if you do not want to upload packages)?' ''`
if [ 0$rsync_user != 0 ]; then
    if [ -e /etc/redhat-release ]; then
	release=`cat /etc/redhat-release`
	release=${release%%.*}
	release=${release##*release }
	os=RHEL$release
    else
	os=$(uname)-$(uname -r)
    fi
    rsync_host=`auto_ask rsync-host 'rsync hostname?' ''`
    rsync_pkg_dir=`auto_ask rsync-pkg-dir 'rsync pkg directory?' "www/pkgsrc/packages$prefix/$os"`
    rsync_report_dir=`auto_ask rsync-report-dir 'rsync report directory?' "www/pkgsrc/reports$prefix/$os"`
fi

pbulk_user=`auto_ask pbulk-user 'User to run pbulk builds?' pbulk`
pbulk_group=`auto_ask pbulk-group 'Group to run pbulk builds?' pbulk`

# Set up env for this tree
PATH=/usr/bin:/usr/sbin:/bin:/sbin
export PATH

# Make sure $pbulk_user user can access everything
umask 022

# When unpacking a tarball for a minimal chroot, tar may not honor some
# permissions for security reasons.
chmod 1777 /tmp /var/tmp

# Copy root ssh in case keys are installed on rsync target
mkdir -p /root

# Remove existing prefix.  It may not have been created by our bootstrap
# script and therefore may not have the correct permissions and options.
rm -rf $prefix

# Generate mk.conf fragments
# Redirect workdir or it will use the pkgsrc tree outside the chroot

cat << EOM > /mk-pbulk.conf
#!/bin/sh -e

# Written by $0

SKIP_LICENSE_CHECK=         yes
ALLOW_VULNERABLE_PACKAGES=  yes
PKG_DEVELOPER=              yes
X11_TYPE=                   modular
FETCH_USING=                curl
MAKE_JOBS=                  $make_jobs
WRKOBJDIR=                  /tmp/pkgbuild
EOM

cat << EOM > /mk-pkg.conf
#!/bin/sh -e

# Written by $0

SKIP_LICENSE_CHECK=         yes
ALLOW_VULNERABLE_PACKAGES=  yes
PKG_DEVELOPER=              yes
X11_TYPE=                   modular
FETCH_USING=                curl
MAKE_JOBS=                  $make_jobs
WRKOBJDIR=                  /tmp/pkgbuild
EOM

mkdir -p /pbulk
cat << EOM > /pbulk/bootstrap
#!/bin/sh -e

# Written by $0

# Redirect workdir or it will use the pkgsrc tree outside the chroot

# Install pbulk under a different prefix, since it wipes out the
# package building prefix before each build.

# Make sure $pbulk_user user can access everything
umask 022

# Create pbulk user
useradd -c 'pbulk user' -m -s /bin/sh $pbulk_user || true

PATH=/pbulk/bin:$PATH
export PATH

if [ ! -e /pbulk/bin/bmake ]; then
    cd /sharedapps/pkgsrc-2017Q1/bootstrap
    ./bootstrap \\
	--abi=64 \\
	--make-jobs=$make_jobs \\
	--prefix=/pbulk \\
	--varbase=/pbulk/var \\
	--prefer-pkgsrc=yes \\
	--mk-fragment=/mk-pbulk.conf \\
	--workdir=/tmp/pbulk-bootstrap
    ./cleanup
fi

cd /sharedapps/pkgsrc-2017Q1/pkgtools/pbulk
bmake install

# Create the package building prefix and create a bootstrap kit, just a
# tarball of prefix with nothing installed but bmake.  The bulk build will
# wipe prefix and recreate it from this tarball before each build.

if [ ! -e /sharedapps/pkg-2017Q1/bin/bmake ]; then
    cd /sharedapps/pkgsrc-2017Q1/bootstrap
    ./bootstrap \\
	--abi=64 \\
	--make-jobs=$make_jobs \\
	--prefix=$prefix \\
	--varbase=$prefix/var \\
	--prefer-pkgsrc=yes \\
	--mk-fragment=/mk-pkg.conf \\
	--workdir=/tmp/pkg-bootstrap
    ./cleanup
fi

cd /
mkdir -p bulklog
chown -Rh ${pbulk_user}:$pbulk_group $prefix $pkgsrc/packages /tmp/pkgbuild
tar zcvf /pbulk/bootstrap.tar.gz .$prefix

# Generate a pbulk.list file.  Users can add whatever packages they want
# to this.

cat << EOM2 > /pbulk/etc/pbulk.list
pkgtools/digest
EOM2

# Update pbulk.conf with some reasonable defaults for this build.

cat << EOM2 >> /pbulk/etc/pbulk.conf

################################################################
# Overrides from $0

# PATH=/pbulk/bin:$PATH
# export PATH

# https://pkgsrc.joyent.com/docs/bulk/
# Limit processes to an hour of CPU time.  Anything which takes longer than
# this is most probably broken.
ulimit -t 3600

bootstrapkit=/pbulk/bootstrap.tar.gz
limited_list=/pbulk/etc/pbulk.list
reuse_scan_results=yes
unprivileged_user=$pbulk_user
make=$prefix/bin/bmake
bulklog=/bulklog

# Must be writable by pbulk user
umask 022
packages=$pkgsrc/packages
prefix=$prefix
pkgdb=$prefix/pkgdb
varbase=$prefix/var
pkgsrc=$pkgsrc

# Change to real IP and add IPs of other bulk build machines if desired
master_mode=no

# Change these if mail is enabled
report_subject_prefix="pkgsrc"
report_recipients="pkgsrc-bulk@netbsd.org"
mail=:

EOM2

EOM

if [ 0$rsync_user != 0 ]; then
    cat << EOM >> /pbulk/bootstrap
cat << EOM2 >> /pbulk/etc/pbulk.conf
pkg_rsync_target="$rsync_user@$rsync_host:$rsync_pkg_dir"
report_rsync_target="$rsync_user@$rsync_host:$rsync_report_dir"
rsync=/pbulk/bin/rsync
EOM2
EOM
else
cat << EOM >> /pbulk/bootstrap
printf "rsync=:\n" >> /pbulk/etc/pbulk.conf
EOM
fi

chmod 755 /pbulk/bootstrap

# Inform the user what to do next.

cat << EOM

Now run

/pbulk/bootstrap

Then edit /pbulk/etc/pbulk.conf and /pbulk/etc/pbulk.list to taste 
and finally run

/pbulk/bin/bulkbuild

EOM
